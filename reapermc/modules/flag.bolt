#   flags:
#       - is_in_air
#       - is_sneaking
#       - is_sprinting
#       - is_swimming
#       - is_on_fire
#       - is_baby
#       - is_holding_{item}
#       - is_holding_{item}_mainhand
#       - is_holding_{item}_offhand


from contextlib import contextmanager
from nbtlib import Byte
from ./util import Rebindable, gen_path
from ./var import var
from ./score_check import ScoreCheck


_PREDICATE_FLAGS = [
    'is_sneaking',
    'is_sprinting',
    'is_swimming',
    'is_on_fire',
    'is_baby'
]

_CACHED_FLAGS = set()
_flag_output = var(int)



class Flag(Rebindable):
    def __init__(self, name, invert=False, initialized=False):
        self.invert = invert
        self.name = name
        self.initialized = initialized

    @contextmanager
    def __branch__(self):
        if not self.initialized:
            if self.name not in _CACHED_FLAGS:
                _CACHED_FLAGS.add(self.name)
                _cache_flag(self.name)

            _check_flag(self.name)

            self.initialized = True

        if self.invert:
            if ScoreCheck(_flag_output) == 0:
                yield True
        else:
            if ScoreCheck(_flag_output) == 1:
                yield True

    def __not__(self):
        return Flag(self.name, invert=not self.invert, initialized=self.initialized)




def _cache_flag(name):
    if name in _PREDICATE_FLAGS:
        _create_predicate_flag(name)

    if name.startswith('is_holding_'):
        _create_holding_flag(name)
    
    elif name == 'is_in_air':
        _create_nbt_flag(name, '{"OnGround": 0b}')



def _check_flag(name):
    global _flag_output

    store result score _flag_output.holder _flag_output.obj:
        if predicate f"{gen_path(f"flag/{name}", internal=True)}"


def _create_predicate_flag(name):
    contents = {
        "condition": "minecraft:entity_properties",
        "entity": "this",
        "predicate": {
            "flags": {
            }
        }
    }

    contents.predicate.flags.update({name: True})
    predicate f"{gen_path(f"flag/{name}", internal=True)}" contents



def _create_holding_flag(name):
    item_id = f"minecraft:{name[11:]}"   # isolates item id and prefixes it with 'minecraft:'

    if name.endswith('_mainhand'):
        item_id = item_id[:-9]
    elif name.endswith('_offhand'):
        item_id = item_id[:-8]

    contents = {
        "condition": "minecraft:alternative",
        "terms": [
            {
                "condition": "minecraft:entity_properties",
                "entity": "this",
                "predicate": {
                    "equipment": {
                        "mainhand": {
                            "items": [
                                item_id
                            ]
                        }
                    }
                }
            },
            {
                "condition": "minecraft:entity_properties",
                "entity": "this",
                "predicate": {
                    "equipment": {
                        "offhand": {
                            "items": [
                                item_id
                            ]
                        }
                    }
                }
            }
        ]
    }

    # remove mainhand or offhand to isolate
    if name.endswith('_mainhand'):
        contents = contents['terms'][0]
    elif name.endswith('_offhand'):
        contents = contents['terms'][1]

    predicate f"{gen_path(f"flag/{name}", internal=True)}" contents



def _create_nbt_flag(name, nbtstring):
    contents = {
        "condition": "minecraft:entity_properties",
        "entity": "this",
        "predicate": {
            "nbt": nbtstring
        }
    }

    predicate f"{gen_path(f"flag/{name}", internal=True)}" contents
